= s_mach.codetools: Macro, codegen and code utility library
Lance Gatlin <lance.gatlin@gmail.com>
v1,27-Dec-2014
:blogpost-status: unpublished
:blogpost-categories: s_mach, scala

*UNDER CONSTRUCTION*

image:https://travis-ci.org/S-Mach/s_mach.codetools.svg[Build Status, link="https://travis-ci.org/S-Mach/s_mach.codetools"]  image:https://coveralls.io/repos/S-Mach/s_mach.codetools/badge.png?branch=master[Test Coverage,link="https://coveralls.io/r/S-Mach/s_mach.codetools"] https://github.com/S-Mach/s_mach.codetools[Code] http://s-mach.github.io/s_mach.codetools/#s_mach.codetools.package[Scaladoc]

+s_mach.codetools+ is an open-source Scala macro, codegen and code utility
library.

+s_mach.codetools+ currently provides:

* +BlackboxHelper+: a wrapper trait that provides utility methods to assist in
macro generation, specifically for generating type-class implementations for
product types
** +BlackboxHelper.ProductType+: a case class that can compute the field names
and types of a product type. Works with all case classes, tuple types and any
other types whose companion object contains a matching apply/unapply method
pair. (See +BlackboxHelper.ProductType+ for details)
* +ReflectPrint+: a demonstration type-class which can create the Scala code
necessary for recreating an instance with the same value (See
+reflectPrint.printApply+)
* +ReflectPrintMacroBuilderImpl+: a reference implementation of a type-class
blackbox macro generator that uses +BlackboxHelper+. The macro implementation
can generate a +ReflectPrint+ implementation for any product type (i.e. case
class or tuple type)
* +ReflectPrintTest+: tests for the generated +ReflectPrint+ for various common
ADT patterns (See +testdata+) in lieu of direct testing of +BlackboxHelper+
since there is currently no blackbox.Context mock available.

== Include in SBT
1. Add to +build.sbt+
+
[source,sbt,numbered]
----
libraryDependencies += "net.s_mach" %% "codetools" % "0.1-SNAPSHOT"
----
NOTE: +s_mach.codetools+ is currently only compiled for Scala 2.11 (though
2.10.4 support can be added if there is interest)

== Versioning
+s_mach.codetools+ uses semantic versioning (http://semver.org/).
+s_mach.codetools+ does not use the package private modifier. Instead, all code
files outside of the +s_mach.codetools.impl+ package form the public interface
and are governed by the rules of semantic versioning. Code files inside the
+s_mach.codetools.impl+ package may be used by downstream applications and
libraries. However, no guarantees are made as to the stability or interface of
code in the +s_mach.codetools.impl+ package between versions.

== Example: ReflectPrint
----
import s_mach.codetools.reflectPrint._

case class Movie(
  name: String,
  year: Int
)

object Movie {
  implicit val reflectPrint_Movie = ReflectPrint.forProductType[Movie]
}

case class Name(
  firstName: String,
  middleName: Option[String],
  lastName: String
)

object Name {
  implicit val reflectPrint_Name = ReflectPrint.forProductType[Name]
}


case class Actor(
  name: Name,
  age: Int,
  movies: Set[Movie]
)

object Actor {
  implicit val reflectPrint_Person = ReflectPrint.forProductType[Actor]
}

val n1 = Name("Gary",Some("Freakn"),"Oldman")
val n2 = Name("Guy",None,"Pearce")
val n3 = Name("Lance",None,"Gatlin")

val m1 = Movie("The Professional",1994)
val m2 = Movie("The Fifth Element",1997)
val m3 = Movie("Memento",1994)
val m4 = Movie("Prometheus",2000)

val a1 = Actor(n1,56,Set(m1,m2))
val a2 = Actor(n2,47,Set(m3,m4))
val a3 = Actor(n3,37,Set.empty)

scala> a1.printApply
res0: String = Actor(name=Name(firstName="Gary",middleName=Some("Freakn"),lastName="Oldman"),age=56,movies=Set(Movie(name="The Professional",year=1994),Movie(name="The Fifth Element",year=1997)))

scala> val alt1 = Actor(name=Name(firstName="Gary",middleName=Some("Freakn"),lastName="Oldman"),age=56,movies=Set(Movie(name="The Professional",year=1994),Movie(name="The Fifth Element",year=1997)))
alt1: Actor = Actor(Name(Gary,Some(Freakn),Oldman),56,Set(Movie(The Professional,1994), Movie(The Fifth Element,1997)))

scala> alt1 == a1
res1: Boolean = true

scala> a1.printUnapply
res2: String = (Name(firstName="Gary",middleName=Some("Freakn"),lastName="Oldman"),56,Set(Movie(name="The Professional",year=1994),Movie(name="The Fifth Element",year=1997)))

scala> val ualt1 = (Name(firstName="Gary",middleName=Some("Freakn"),lastName="Oldman"),56,Set(Movie(name="The Professional",year=1994),Movie(name="The Fifth Element",year=1997)))
ualt1: (Name, Int, scala.collection.immutable.Set[Movie]) = (Name(Gary,Some(Freakn),Oldman),56,Set(Movie(The Professional,1994), Movie(The Fifth Element,1997)))

scala> ualt1 == Actor.unapply(a1).get
res3: Boolean = true

scala> import ReflectPrintFormat.Implicits.verbose
import ReflectPrintFormat.Implicit.verbose

scala> a2.printApply
res2: String =
Actor(
  name = Name(
    firstName = "Guy",
    middleName = None,
    lastName = "Pearce"
  ),
  age = 47,
  movies = Set(
    Movie(
      name = "Memento",
      year = 1994
    ),
    Movie(
      name = "Prometheus",
      year = 2000
    )
  )
)

scala> a3.printApply
res3: String =
Actor(
 name = Name(
  firstName = "Lance",
  middleName = None,
  lastName = "Gatlin"
 ),
 age = 37,
 movies = Set.empty
)
----